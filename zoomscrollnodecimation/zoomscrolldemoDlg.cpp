// zoomscrolldemoDlg.cpp : implementation file
//

#include "stdafx.h"
#include "udl1config.h"
#include "zoomscrolldemoDlg.h"
#include "chartdir.h"
#include <math.h>
#include <time.h>
#include <algorithm>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CZoomscrolldemoDlg dialog

//
// Constructor
//
CZoomscrolldemoDlg::CZoomscrolldemoDlg(CWnd* pParent /*=NULL*/)
: CDialog(CZoomscrolldemoDlg::IDD, pParent)
, m_showMinMax(FALSE)
, m_noDecimation(FALSE)
{
	//{{AFX_DATA_INIT(CZoomscrolldemoDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	m_multiline = FALSE;
	m_waveprint = FALSE;
	m_waveSegmentCurrent=0;
	m_printDlgPtr=NULL;
}

//
// Destructor
//
CZoomscrolldemoDlg::~CZoomscrolldemoDlg()
{
	//delete m_dataTable;
	delete m_ChartViewer.getChart();
}

void CZoomscrolldemoDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CZoomscrolldemoDlg)
	DDX_Control(pDX, IDC_StartDate, m_StartDate);
	DDX_Control(pDX, IDC_Duration, m_Duration);
	DDX_Control(pDX, IDC_VScrollBar, m_VScrollBar);
	DDX_Control(pDX, IDC_HScrollBar, m_HScrollBar);
	DDX_Control(pDX, IDC_XZoomPB, m_XZoomPB);
	DDX_Control(pDX, IDC_PointerPB, m_PointerPB);
	DDX_Control(pDX, IDC_ChartViewer, m_ChartViewer);
	//}}AFX_DATA_MAP
	DDX_Check(pDX, IDC_CHECK_SHOWMINMAX, m_showMinMax);
	DDX_Check(pDX, IDC_CHECK_NODECIMATION, m_noDecimation);
}

BEGIN_MESSAGE_MAP(CZoomscrolldemoDlg, CDialog)
	//{{AFX_MSG_MAP(CZoomscrolldemoDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_PointerPB, OnPointerPB)
	ON_BN_CLICKED(IDC_ZoomInPB, OnZoomInPB)
	ON_BN_CLICKED(IDC_ZoomOutPB, OnZoomOutPB)
	ON_BN_CLICKED(IDC_XZoomPB, OnXZoomPB)
	ON_BN_CLICKED(IDC_XYZoomPB, OnXYZoomPB)
	ON_BN_CLICKED(IDC_ChartViewer, OnChartViewer)
	ON_CONTROL(CVN_ViewPortChanged, IDC_ChartViewer, OnViewPortChanged)
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_NOTIFY(DTN_DATETIMECHANGE, IDC_StartDate, OnDatetimechangeStartDate)
	ON_CBN_SELCHANGE(IDC_Duration, OnSelchangeDuration)
	ON_CBN_KILLFOCUS(IDC_Duration, OnKillfocusDuration)
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_BUTTON_PRINT, &CZoomscrolldemoDlg::OnBnClickedButtonPrint)
	ON_BN_CLICKED(IDC_BUTTON_SAVECHART, &CZoomscrolldemoDlg::OnBnClickedButtonSavechart)
	ON_BN_CLICKED(IDC_BUTTON_ZOOMALL, &CZoomscrolldemoDlg::OnBnClickedButtonZoomall)
	ON_BN_CLICKED(IDC_BUTTON_PREVWAVE, &CZoomscrolldemoDlg::OnBnClickedButtonPrevwave)
	ON_BN_CLICKED(IDC_BUTTON_NEXTWAVE, &CZoomscrolldemoDlg::OnBnClickedButtonNextwave)
	ON_BN_CLICKED(IDC_BUTTON_FIRSTWAVE, &CZoomscrolldemoDlg::OnBnClickedButtonFirstwave)
	ON_BN_CLICKED(IDC_BUTTON_LASTWAVE, &CZoomscrolldemoDlg::OnBnClickedButtonLastwave)
	ON_BN_CLICKED(IDC_CHECK_SHOWMINMAX, &CZoomscrolldemoDlg::OnBnClickedCheckShowminmax)
	ON_BN_CLICKED(IDC_CHECK_NODECIMATION, &CZoomscrolldemoDlg::OnBnClickedCheckNodecimation)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CZoomscrolldemoDlg message handlers

//
// Initialization
//
BOOL CZoomscrolldemoDlg::OnInitDialog()
{
	UINT32 i;
	CDialog::OnInitDialog();

	Chart::setLicenseCode("RDST-25PS-KMGP-AU23-5C83-6407",NULL); 

	// *** code automatically generated by VC++ MFC AppWizard ***
	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);         // Set big icon
	SetIcon(m_hIcon, FALSE);        // Set small icon

	// Load icons to mouse usage buttons
	loadButtonIcon(IDC_PointerPB, IDI_PointerPB, 100, 20);  
	loadButtonIcon(IDC_ZoomInPB, IDI_ZoomInPB, 100, 20);    
	loadButtonIcon(IDC_ZoomOutPB, IDI_ZoomOutPB, 100, 20);
	loadButtonIcon(IDC_BUTTON_ZOOMALL, IDI_ZoomAllPB, 100,20);

	// Load icons to zoom/scroll direction control buttons
	loadButtonIcon(IDC_XZoomPB, IDI_XZoomPB, 105, 20);
	loadButtonIcon(IDC_XYZoomPB, IDI_XYZoomPB, 105, 20);

	//Fix problems cause by 125% font size settings...  We have to manually position and size the window and all of its associated controls
	SetWindowPos(&wndTop,0,0,1024,610,SWP_NOMOVE|SWP_NOZORDER);

	RECT windowRect;
	((CWnd*)GetDlgItem(IDC_HScrollBar))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_HScrollBar x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_HScrollBar))->SetWindowPos(&wndTop,138,551,855,16,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_VScrollBar))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_VScrollBar x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_VScrollBar))->SetWindowPos(&wndTop,993,0,17,553,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_ChartViewer))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_ChartViewer x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_ChartViewer))->SetWindowPos(&wndTop,138,7,23,21,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_PointerPB))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_PointerPB x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_PointerPB))->SetWindowPos(&wndTop,12,13,114,26,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_ZoomInPB))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_ZoomInPB x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_ZoomInPB))->SetWindowPos(&wndTop,12,39,114,26,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_ZoomOutPB))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_ZoomOutPB x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_ZoomOutPB))->SetWindowPos(&wndTop,12,65,114,26,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_BUTTON_ZOOMALL))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_BUTTON_ZOOMALL x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_BUTTON_ZOOMALL))->SetWindowPos(&wndTop,12,93,114,23,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_XZoomPB))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_XZoomPB x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_XZoomPB))->SetWindowPos(&wndTop,12,179,114,26,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_XYZoomPB))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_XYZoomPB x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_XYZoomPB))->SetWindowPos(&wndTop,12,205,114,26,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_BUTTON_PRINT))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_BUTTON_PRINT x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_BUTTON_PRINT))->SetWindowPos(&wndTop,12,518,114,26,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_STATIC_ZOOMMODE))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_STATIC_ZOOMMODE x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_STATIC_ZOOMMODE))->SetWindowPos(&wndTop,12,158,108,20,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_BUTTON_SAVECHART))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_BUTTON_SAVECHART x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_BUTTON_SAVECHART))->SetWindowPos(&wndTop,12,544,114,23,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_STATIC_WAVEPRINT))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_STATIC_WAVEPRINT x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_STATIC_WAVEPRINT))->SetWindowPos(&wndTop,11,262,114,23,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_BUTTON_PREVWAVE))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_BUTTON_PREVWAVE x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_BUTTON_PREVWAVE))->SetWindowPos(&wndTop,11,280,114,23,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_BUTTON_NEXTWAVE))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_BUTTON_NEXTWAVE x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_BUTTON_NEXTWAVE))->SetWindowPos(&wndTop,11,304,114,23,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_BUTTON_FIRSTWAVE))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_BUTTON_FIRSTWAVE x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_BUTTON_FIRSTWAVE))->SetWindowPos(&wndTop,11,328,114,23,SWP_NOZORDER);

	((CWnd*)GetDlgItem(IDC_BUTTON_LASTWAVE))->GetWindowRect(&windowRect);
	ScreenToClient(&windowRect);
	printf("IDC_BUTTON_LASTWAVE x=%lu, y=%lu, width=%lu, height=%lu\r\n",windowRect.left,windowRect.top,windowRect.right-windowRect.left,windowRect.bottom-windowRect.top);
	((CWnd*)GetDlgItem(IDC_BUTTON_LASTWAVE))->SetWindowPos(&wndTop,11,353,114,23,SWP_NOZORDER);

	m_fontForStatic.CreateFont(14, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE,
												ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
												DEFAULT_PITCH, "Tahoma");

	((CWnd*)GetDlgItem(IDC_STATIC_ZOOMMODE))->SetFont(&m_fontForStatic,TRUE);
	((CWnd*)GetDlgItem(IDC_BUTTON_PREVWAVE))->SetFont(&m_fontForStatic,TRUE);
	((CWnd*)GetDlgItem(IDC_BUTTON_NEXTWAVE))->SetFont(&m_fontForStatic,TRUE);
	((CWnd*)GetDlgItem(IDC_BUTTON_FIRSTWAVE))->SetFont(&m_fontForStatic,TRUE);
	((CWnd*)GetDlgItem(IDC_BUTTON_LASTWAVE))->SetFont(&m_fontForStatic,TRUE);
	((CWnd*)GetDlgItem(IDC_STATIC_WAVEPRINT))->SetFont(&m_fontForStatic,TRUE);
	((CWnd*)GetDlgItem(IDC_BUTTON_PRINT))->SetFont(&m_fontForStatic,TRUE);
	((CWnd*)GetDlgItem(IDC_BUTTON_SAVECHART))->SetFont(&m_fontForStatic,TRUE);
	

	if (m_waveprint)
	{
		((CWnd*)GetDlgItem(IDC_BUTTON_PREVWAVE))->ShowWindow(TRUE);
		((CWnd*)GetDlgItem(IDC_BUTTON_NEXTWAVE))->ShowWindow(TRUE);
		((CWnd*)GetDlgItem(IDC_BUTTON_FIRSTWAVE))->ShowWindow(TRUE);
		((CWnd*)GetDlgItem(IDC_BUTTON_LASTWAVE))->ShowWindow(TRUE);
		((CWnd*)GetDlgItem(IDC_STATIC_WAVEPRINT))->ShowWindow(TRUE);
	}
	else
	{
		((CWnd*)GetDlgItem(IDC_BUTTON_PREVWAVE))->ShowWindow(FALSE);
		((CWnd*)GetDlgItem(IDC_BUTTON_NEXTWAVE))->ShowWindow(FALSE);
		((CWnd*)GetDlgItem(IDC_BUTTON_FIRSTWAVE))->ShowWindow(FALSE);
		((CWnd*)GetDlgItem(IDC_BUTTON_LASTWAVE))->ShowWindow(FALSE);
		((CWnd*)GetDlgItem(IDC_STATIC_WAVEPRINT))->ShowWindow(FALSE);
	}

	m_bmp.data=NULL;
	m_bmp.len=0;

	//
	// Initialize member variables
	//
	m_extBgColor = getDefaultBgColor();     // Default background color
	m_minValue = m_maxValue = 0;            // y axes ranges


	if (m_waveprint)
	{
		m_timeStampsA=DoubleArray(m_timeStampsB.data+m_waveSegments[m_waveSegmentCurrent].startIndex,m_waveSegments[m_waveSegmentCurrent].endIndex-m_waveSegments[m_waveSegmentCurrent].startIndex);
		m_dataSeriesA=DoubleArray(m_dataSeriesB.data+m_waveSegments[m_waveSegmentCurrent].startIndex,m_waveSegments[m_waveSegmentCurrent].endIndex-m_waveSegments[m_waveSegmentCurrent].startIndex);
	}

	//
	// In this demo, we deduce the horizontal scroll range from the data.
	//

	if (!m_multiline)
	{
		// Earliest date is the first timestamp
		m_minDate = m_timeStampsA[0];
		m_maxDate = m_timeStampsA[m_timeStampsA.len - 1];
		// Duration is the seconds elapsed of the last timestamp from the earliest date
		m_dateRange = m_maxDate - m_minDate;
	}
	else
	{
		// Earliest date is the first timestamp
		if (m_timeStampsA.len) m_minDate = m_timeStampsA[0]; 
		else 
			if (m_timeStampsB.len) m_minDate = m_timeStampsB[0];
			else
				m_timeStampsC[0]; 
		if (m_timeStampsB.len) if (m_timeStampsB[0]<m_minDate) m_minDate=m_timeStampsB[0];
		if (m_timeStampsC.len) if (m_timeStampsC[0]<m_minDate) m_minDate=m_timeStampsC[0];

		// Latest date lis late time stamp
		if (m_timeStampsA.len) m_maxDate = m_timeStampsA[m_timeStampsA.len-1];
		else
			if (m_timeStampsB.len) m_maxDate = m_timeStampsB[m_timeStampsB.len-1];
		else
			m_maxDate = m_timeStampsC[m_timeStampsC.len-1];

		if (m_timeStampsB.len) if (m_timeStampsB[m_timeStampsB.len-1]>m_maxDate) m_maxDate=m_timeStampsB[m_timeStampsB.len-1];
		if (m_timeStampsC.len) if (m_timeStampsC[m_timeStampsC.len-1]>m_maxDate) m_maxDate=m_timeStampsC[m_timeStampsC.len-1];

		// Duration is the seconds elapsed of the last timestamp from the earliest date
		m_dateRange = m_maxDate - m_minDate;

	}

	//Compute min/max
	m_dataSeriesAMinTime=m_timeStampsA[0];
	m_dataSeriesAMinVal=m_dataSeriesA[0];
	m_dataSeriesAMaxTime=m_timeStampsA[0];
	m_dataSeriesAMaxVal=m_dataSeriesA[0];
	for (i=0; i<m_dataSeriesA.len; i++)
	{
		if (m_dataSeriesA[i]<m_dataSeriesAMinVal) {m_dataSeriesAMinTime=m_timeStampsA[i];m_dataSeriesAMinVal=m_dataSeriesA[i];}
		if (m_dataSeriesA[i]>m_dataSeriesAMaxVal) {m_dataSeriesAMaxTime=m_timeStampsA[i];m_dataSeriesAMaxVal=m_dataSeriesA[i];}
	}


	m_currentDuration=m_dateRange;

	// Convert the start time (in chartTime format) as an MFC CTime value
	int startYMD = Chart::getChartYMD(m_minDate/*m_timeStampsA[0]*/);
	int startHMS = (int)fmod(m_minDate/*m_timeStampsA[0]*/, 86400);
	CTime startDate = CTime(startYMD / 10000, (startYMD % 10000) / 100, startYMD % 100,
		startHMS / 3600, (startHMS % 3600) / 60, startHMS % 60);

	// Convert the end time (in chartTime format) as an MFC CTime value
	int endYMD = Chart::getChartYMD(m_maxDate/*m_timeStampsA[m_timeStampsA.len - 1]*/);
	int endHMS = (int)fmod(m_maxDate/*m_timeStampsA[m_timeStampsA.len - 1]*/, 86400);
	CTime endDate = CTime(endYMD / 10000, (endYMD % 10000) / 100, endYMD % 100,
		endHMS / 3600, (endHMS % 3600) / 60, endHMS % 60);

	// Set the startDate and endDate to the CDateTimeCtrl control 
	m_StartDate.SetRange(&startDate, &endDate);

	// In this demo, the maximum zoom-in is set to 10 days (1 day = 86400 seconds)
	if (!m_waveprint)
		m_minDuration = 10; //1 * 86400;
	else
		m_minDuration = 2; //1 * 86400;


	// Set up the ChartViewer to reflect the visible and minimum duration
	m_ChartViewer.setZoomInWidthLimit(m_minDuration / m_dateRange);
	m_ChartViewer.setViewPortWidth(m_currentDuration / m_dateRange);
	m_ChartViewer.setViewPortLeft(1 - m_ChartViewer.getViewPortWidth());

	// Initially set the mouse to drag to scroll mode in horizontal direction.
	m_PointerPB.SetCheck(1);
	m_XZoomPB.SetCheck(1);
	m_ChartViewer.setMouseUsage(Chart::MouseUsageScroll);

	// Can update chart now
	m_ChartViewer.updateViewPort(true, true);

	// Update wave print area and buttons
	if (m_waveprint) UpdateWaveSegment();

	return TRUE;
}

// *** code automatically generated by VC++ MFC AppWizard ***
// If you add a minimize button to your dialog, you will need the code below
// to draw the icon.  For MFC applications using the document/view model,
// this is automatically done for you by the framework.
void CZoomscrolldemoDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// *** code automatically generated by VC++ MFC AppWizard ***
// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CZoomscrolldemoDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

//
// User clicks on the Pointer pushbutton
//
void CZoomscrolldemoDlg::OnPointerPB() 
{
	m_ChartViewer.setMouseUsage(Chart::MouseUsageScroll);   
}

//
// User clicks on the Zoom In pushbutton
//
void CZoomscrolldemoDlg::OnZoomInPB() 
{
	m_ChartViewer.setMouseUsage(Chart::MouseUsageZoomIn);   
}

//
// User clicks on the Zoom Out pushbutton
//
void CZoomscrolldemoDlg::OnZoomOutPB() 
{
	m_ChartViewer.setMouseUsage(Chart::MouseUsageZoomOut);  
}

//
// User clicks on the X-Zoom pushbutton
//
void CZoomscrolldemoDlg::OnXZoomPB() 
{
	m_ChartViewer.setZoomDirection(Chart::DirectionHorizontal); 
	m_ChartViewer.setScrollDirection(Chart::DirectionHorizontal);

	// Viewport is always unzoomed as y-axis is auto-scaled
	m_ChartViewer.setViewPortTop(0);
	m_ChartViewer.setViewPortHeight(1);

	// Update chart to auto-scale axis
	m_ChartViewer.updateViewPort(true, true);
}

//
// User clicks on the XY-Zoom pushbutton
//
void CZoomscrolldemoDlg::OnXYZoomPB() 
{
	m_ChartViewer.setZoomDirection(Chart::DirectionHorizontalVertical); 
	m_ChartViewer.setScrollDirection(Chart::DirectionHorizontalVertical);   
}

//
// User selects a start date from the CDateTimeCtrl control
//
void CZoomscrolldemoDlg::OnDatetimechangeStartDate(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// Get the selected date
	CTime startDate;
	m_StartDate.GetTime(startDate);

	// Compute the new view port position based on the selected date
	m_ChartViewer.setViewPortLeft(
		(Chart::chartTime2((int)startDate.GetTime()) - m_minDate) / m_dateRange);
	m_ChartViewer.updateViewPort(true, true);

	*pResult = 0;
}

//
// User selects a duration from the Duration combo box
//
void CZoomscrolldemoDlg::OnSelchangeDuration() 
{
	// Get the selected duration
	CString text;
	m_Duration.GetLBText(m_Duration.GetCurSel(), text);

	// Validate and update the chart
	validateDuration(text);
}

//
// The Duration combo box lost focus (User may have entered a new duration.)
//
void CZoomscrolldemoDlg::OnKillfocusDuration() 
{
	// Get the duration text
	CString text;
	m_Duration.GetWindowText(text);

	// Validate and update the chart
	validateDuration(text);
}

//
// User presses "Enter" key. (User may have entered a new duration.)
//
void CZoomscrolldemoDlg::OnOK()
{
	// Same processing as OnKillfocusDuration
	OnKillfocusDuration();
}

//
// User clicks on the the horizontal scroll bar 
//
void CZoomscrolldemoDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	if (nSBCode != SB_ENDSCROLL)
	{
		// User is still scrolling

		// Set the view port based on the scroll bar
		m_ChartViewer.setViewPortLeft(moveScrollBar(nSBCode, nPos, pScrollBar));
		// Update the chart image only, but no need to update the image map.
		m_ChartViewer.updateViewPort(true, false);
	}
	else
		// Scroll bar has stoped moving. Can update image map now.
		m_ChartViewer.updateViewPort(false, true);
}       

//
// User clicks on the the vertical scroll bar 
//
void CZoomscrolldemoDlg::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	if (nSBCode != SB_ENDSCROLL)
	{
		// User is still scrolling

		// Set the view port based on the scroll bar
		m_ChartViewer.setViewPortTop(moveScrollBar(nSBCode, nPos, pScrollBar));
		// Update the chart image only, but no need to update the image map.
		m_ChartViewer.updateViewPort(true, false);
	}
	else
		// Scroll bar has stoped moving. Can update image map now.
		m_ChartViewer.updateViewPort(false, true);
}

//
// CChartViewer ViewPortChanged event
//
void CZoomscrolldemoDlg::OnViewPortChanged()
{
	//
	// Set up the scroll bars to reflect the current position and size of the view port
	//
	SCROLLINFO info;
	info.cbSize = sizeof(SCROLLINFO);
	info.fMask = SIF_ALL;
	info.nMin = 0;
	info.nMax = 0x1fffffff;

	m_HScrollBar.EnableWindow(m_ChartViewer.getViewPortWidth() < 1);
	if (m_ChartViewer.getViewPortWidth() < 1)
	{
		info.nPage = (int)ceil(m_ChartViewer.getViewPortWidth() * (info.nMax - info.nMin));
		info.nPos = (int)(0.5 + m_ChartViewer.getViewPortLeft() * (info.nMax - info.nMin))
			+ info.nMin;
		m_HScrollBar.SetScrollInfo(&info);
	}

	m_VScrollBar.EnableWindow(m_ChartViewer.getViewPortHeight() < 1);
	if (m_ChartViewer.getViewPortHeight() < 1)
	{
		info.nPage = (int)ceil(m_ChartViewer.getViewPortHeight() * (info.nMax - info.nMin));
		info.nPos = (int)(0.5 + m_ChartViewer.getViewPortTop() * (info.nMax - info.nMin))
			+ info.nMin;
		m_VScrollBar.SetScrollInfo(&info);
	}

	//
	// Set the start date CDateTimeCtrl control and duration combo box to reflect the current
	// position and size of the view port.
	//

	// Compute the start date (in chartTime) and duration (in seconds) of the view port
	double currentStartDate = m_minDate + (int)(0.5 + m_ChartViewer.getViewPortLeft() 
		* m_dateRange);
	m_currentDuration = (int)(0.5 + m_ChartViewer.getViewPortWidth() * m_dateRange);

	// Set the CDateTimeCtrl control to reflect the start date
	int startYMD = Chart::getChartYMD(currentStartDate);
	int startHMS = (int)fmod(currentStartDate, 86400);
	CTime startDate = CTime(startYMD / 10000, (startYMD % 10000) / 100, startYMD % 100,
		startHMS / 3600, (startHMS % 3600) / 60, startHMS % 60);
	m_StartDate.SetTime(&startDate);

	// Set the duration combo box to reflect the duration (in days)
	CString buffer;
	buffer.Format(_T("%d"), (int)(0.5 + m_currentDuration / 86400));
	m_Duration.SetWindowText(buffer);

	//
	// Update chart and image map if necessary
	//
	if (m_ChartViewer.needUpdateChart())
		drawChart(&m_ChartViewer);
	if (m_ChartViewer.needUpdateImageMap())
		updateImageMap(&m_ChartViewer);
}

//
// User clicks on the CChartViewer
//
void CZoomscrolldemoDlg::OnChartViewer() 
{
	ImageMapHandler *handler = m_ChartViewer.getImageMapHandler();
	if (0 != handler)
	{
		//
		// Query the ImageMapHandler to see if the mouse is on a clickable hot spot. We 
		// consider the hot spot as clickable if its href ("path") parameter is not empty.
		//
		const char *path = handler->getValue("path");
		if ((0 != path) && (0 != *path))
		{
			// In this sample code, we just show all hot spot parameters.
			//CHotSpotDlg hs;
			//hs.SetData(handler);
			//hs.DoModal();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CZoomscrolldemoDlg methods

//
// Handle scroll bar events
//
double CZoomscrolldemoDlg::moveScrollBar(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar)
{
	//
	// Get current scroll bar position
	//
	SCROLLINFO info;
	info.cbSize = sizeof(SCROLLINFO);
	info.fMask = SIF_ALL;
	pScrollBar->GetScrollInfo(&info);

	//
	// Compute new position based on the type of scroll bar events
	//
	int newPos = info.nPos;
	switch (nSBCode)
	{
	case SB_LEFT:
		newPos = info.nMin;
		break;
	case SB_RIGHT:
		newPos = info.nMax;
		break;
	case SB_LINELEFT:
		newPos -= (info.nPage > 10) ? info.nPage / 10 : 1;
		break;
	case SB_LINERIGHT:
		newPos += (info.nPage > 10) ? info.nPage / 10 : 1;
		break;
	case SB_PAGELEFT:
		newPos -= info.nPage;
		break;
	case SB_PAGERIGHT:
		newPos += info.nPage;
		break;
	case SB_THUMBTRACK:
		newPos = info.nTrackPos;
		break;
	}
	if (newPos < info.nMin) newPos = info.nMin;
	if (newPos > info.nMax) newPos = info.nMax;

	// Update the scroll bar with the new position
	pScrollBar->SetScrollPos(newPos);

	// Returns the position of the scroll bar as a ratio of its total length
	return ((double)(newPos - info.nMin)) / (info.nMax - info.nMin);
}

//
// Validate the contents of the duration combo box and update ViewPortWidth accordingly
//
void CZoomscrolldemoDlg::validateDuration(const CString &text)
{
	// Parse the duration text
	double newDuration = _tcstod(text, 0) * 86400;

	// Duration too short or not numeric?
	if (newDuration < m_minDuration) 
		newDuration = m_minDuration;

	if (newDuration != m_currentDuration)
	{
		// Set the ViewPortWidth according to the new duration
		m_currentDuration = newDuration;
		m_ChartViewer.setViewPortWidth(newDuration / m_dateRange);

		// Update the chart
		m_ChartViewer.updateViewPort(true, true);
	}
}

//
// Draw the chart and display it in the given viewer
//
void CZoomscrolldemoDlg::drawChart(CChartViewer *viewer)
{
	//
	// In this demo, we copy the visible part of the data to a separate buffer for chart
	// plotting. 
	//
	// Note that if you only have a small amount of data (a few hundred data points), it
	// may be easier to just plot all data in any case (so the following copying code is 
	// not needed), and let ChartDirector "clip" the chart to the plot area. 
	//

	// Using ViewPortLeft and ViewPortWidth, get the start and end dates of the view port.
	double viewPortStartDate = m_minDate + (__int64)(viewer->getViewPortLeft() * 
		m_dateRange + 0.5);
	double viewPortEndDate = viewPortStartDate + (__int64)(viewer->getViewPortWidth() * 
		m_dateRange + 0.5);

	// Get the starting index of the array using the start date
	int startIndexA = (int)(std::lower_bound(m_timeStampsA.data, m_timeStampsA.data + m_timeStampsA.len,viewPortStartDate) - m_timeStampsA.data);
	if ((startIndexA > 0) && (m_timeStampsA[startIndexA] != viewPortStartDate)) 
		--startIndexA;
	// Get the ending index of the array using the end date
	int endIndexA = (int)(std::upper_bound(m_timeStampsA.data, m_timeStampsA.data + m_timeStampsA.len,viewPortEndDate) - m_timeStampsA.data);
	if (endIndexA >= m_timeStampsA.len - 1)
		endIndexA = m_timeStampsA.len - 1;

	// Get the starting index of the array using the start date
	int startIndexB = (int)(std::lower_bound(m_timeStampsB.data, m_timeStampsB.data + m_timeStampsB.len,viewPortStartDate) - m_timeStampsB.data);
	if ((startIndexB > 0) && (m_timeStampsB[startIndexB] != viewPortStartDate)) 
		--startIndexB;
	// Get the ending index of the array using the end date
	int endIndexB = (int)(std::upper_bound(m_timeStampsB.data, m_timeStampsB.data + m_timeStampsB.len,viewPortEndDate) - m_timeStampsB.data);
	if (endIndexB >= m_timeStampsB.len - 1)
		endIndexB = m_timeStampsB.len - 1;

	// Get the starting index of the array using the start date
	int startIndexC = (int)(std::lower_bound(m_timeStampsC.data, m_timeStampsC.data + m_timeStampsC.len,viewPortStartDate) - m_timeStampsC.data);
	if ((startIndexC > 0) && (m_timeStampsC[startIndexC] != viewPortStartDate)) 
		--startIndexC;
	// Get the ending index of the array using the end date
	int endIndexC = (int)(std::upper_bound(m_timeStampsC.data, m_timeStampsC.data + m_timeStampsC.len,viewPortEndDate) - m_timeStampsC.data);
	if (endIndexC >= m_timeStampsC.len - 1)
		endIndexC = m_timeStampsC.len - 1;

	// Get the length
	int noOfPointsA = endIndexA - startIndexA + 1;
	int noOfPointsB = endIndexB - startIndexB + 1;
	int noOfPointsC = endIndexC - startIndexC + 1;

	// We copy the visible data from the main arrays to separate data arrays
	double* viewPortTimeStampsA = new double[noOfPointsA];
	double* viewPortTimeStampsB = new double[noOfPointsB];
	double* viewPortTimeStampsC = new double[noOfPointsC];
	double* viewPortDataSeriesA = new double[noOfPointsA];
	double* viewPortDataSeriesB = new double[noOfPointsB];
	double* viewPortDataSeriesC = new double[noOfPointsC];
	int arraySizeInBytesA = noOfPointsA * sizeof(double);
	int arraySizeInBytesB = noOfPointsB * sizeof(double);
	int arraySizeInBytesC = noOfPointsC * sizeof(double);
	memcpy(viewPortTimeStampsA, m_timeStampsA.data + startIndexA, arraySizeInBytesA);
	memcpy(viewPortDataSeriesA, m_dataSeriesA.data + startIndexA, arraySizeInBytesA);
	if (m_multiline)
	{
		memcpy(viewPortTimeStampsB, m_timeStampsB.data + startIndexB, arraySizeInBytesB);
		memcpy(viewPortDataSeriesB, m_dataSeriesB.data + startIndexB, arraySizeInBytesB);
		memcpy(viewPortTimeStampsC, m_timeStampsC.data + startIndexC, arraySizeInBytesC);
		memcpy(viewPortDataSeriesC, m_dataSeriesC.data + startIndexC, arraySizeInBytesC);
	}

	if (0/*!m_noDecimation*/)
	{
		if ((noOfPointsA >= 520))
		{
			//
			// Zoomable chart with high zooming ratios often need to plot many thousands of 
			// points when fully zoomed out. However, it is usually not needed to plot more
			// data points than the resolution of the chart. Plotting too many points may cause
			// the points and the lines to overlap. So rather than increasing resolution, this 
			// reduces the clarity of the chart. So it is better to aggregate the data first if
			// there are too many points.
			//
			// In our current example, the chart only has 520 pixels in width and is using a 2
			// pixel line width. So if there are more than 520 data points, we aggregate the 
			// data using the ChartDirector aggregation utility method.
			//
			// If in your real application, you do not have too many data points, you may 
			// remove the following code altogether.
			//

			// Set up an aggregator to aggregate the data based on regular sized slots
			ArrayMath mA(DoubleArray(viewPortTimeStampsA, noOfPointsA));
			mA.selectRegularSpacing(noOfPointsA / 260);
			// For the timestamps, take the first timestamp on each slot
			int aggregatedNoOfPointsA = mA.aggregate(DoubleArray(viewPortTimeStampsA, noOfPointsA),Chart::AggregateFirst).len;
			// For the data values, aggregate by taking the averages
			mA.aggregate(DoubleArray(viewPortDataSeriesA, noOfPointsA), Chart::AggregateAvg);
			//mA.aggregate(DoubleArray(viewPortDataSeriesA, noOfPointsA), Chart::AggregateMed); 
			noOfPointsA = aggregatedNoOfPointsA;
		}
		if (m_multiline&&(noOfPointsB >=520))
		{
				ArrayMath mB(DoubleArray(viewPortTimeStampsB, noOfPointsB));
				mB.selectRegularSpacing(noOfPointsB / 260);
				int aggregatedNoOfPointsB = mB.aggregate(DoubleArray(viewPortTimeStampsB, noOfPointsB),Chart::AggregateFirst).len;
				mB.aggregate(DoubleArray(viewPortDataSeriesB, noOfPointsB), Chart::AggregateAvg);
				//mB.aggregate(DoubleArray(viewPortDataSeriesB, noOfPointsB), Chart::AggregateMed);
				noOfPointsB = aggregatedNoOfPointsB;
		}
		if (m_multiline&&(noOfPointsC >=520))
		{
				ArrayMath mC(DoubleArray(viewPortTimeStampsC, noOfPointsC));
				mC.selectRegularSpacing(noOfPointsC / 260);
				int aggregatedNoOfPointsC = mC.aggregate(DoubleArray(viewPortTimeStampsC, noOfPointsC),Chart::AggregateFirst).len;
				mC.aggregate(DoubleArray(viewPortDataSeriesC, noOfPointsC), Chart::AggregateAvg);
				//mC.aggregate(DoubleArray(viewPortDataSeriesC, noOfPointsC), Chart::AggregateMed);
				noOfPointsC = aggregatedNoOfPointsC;
		}
	}

	//
	// Now we have obtained the data, we can plot the chart. 
	//

	///////////////////////////////////////////////////////////////////////////////////////
	// Step 1 - Configure overall chart appearance. 
	///////////////////////////////////////////////////////////////////////////////////////

	// Create an XYChart object 600 x 300 pixels in size, with pale blue (0xf0f0ff) 
	// background, black (000000) border, 1 pixel raised effect, and with a rounded frame.
	XYChart *c = new XYChart(853, 543, 0xf0f0ff, 0, 1);
	c->setRoundedFrame(m_extBgColor);

	// Set the plotarea at (52, 60) and of size 520 x 192 pixels. Use white (ffffff) 
	// background. Enable both horizontal and vertical grids by setting their colors to 
	// grey (cccccc). Set clipping mode to clip the data lines to the plot area.
	c->setPlotArea(52, 60, 780, 425, 0xffffff, -1, -1, 0xcccccc, 0xcccccc);
	c->setClipping();

	// Add a top title to the chart using 15 pts Times New Roman Bold Italic font, with a 
	// light blue (ccccff) background, black (000000) border, and a glass like raised effect.
	c->addTitle(m_chartTitle, "timesbi.ttf", 15
		)->setBackground(0xccccff, 0x0, Chart::glassEffect());

	// Add a bottom title to the chart to show the date range of the axis, with a light blue 
	// (ccccff) background.
#if 0
	char formattedStartDate[32];
	char formattedEndDate[32];
	strcpy(formattedStartDate, c->formatValue(viewPortStartDate, "{value|mmm dd, yyyy}"));
	strcpy(formattedEndDate, c->formatValue(viewPortEndDate, "{value|mmm dd, yyyy}"));
	char buffer[2048];
	sprintf(buffer, "From <*font=arialbi.ttf*>%s<*/font*> to <*font=arialbi.ttf*>%s<*/font*>"
		" (Duration <*font=arialbi.ttf*>%d<*/font*> days)", formattedStartDate, 
		formattedEndDate, (int)((viewPortEndDate - viewPortStartDate) / 86400.0 + 0.5));
	c->addTitle(Chart::Bottom, buffer, "ariali.ttf", 10)->setBackground(0xccccff);
#endif

	// Add a legend box at the top of the plot area with 9pts Arial Bold font with flow layout. 
	c->addLegend(50, 33, false, "arialbd.ttf", 9)->setBackground(Chart::Transparent, 
		Chart::Transparent);

	// Set axes width to 2 pixels
	c->yAxis()->setWidth(2);
	c->xAxis()->setWidth(2);

	c->xAxis()->setTitle("Date/Time("+m_timeZoneStr+")", "arialbd.ttf", 9);

	// Add a title to the y-axis
	c->yAxis()->setTitle("Reading", "arialbd.ttf", 9);

	if (!m_multiline&&m_showMinMax)
	{
		Mark *xMarkMax = c->xAxis()->addMark(m_dataSeriesAMaxTime,0x800000FF,"Max","arialbd.ttf",7);
		Mark *xMarkMin = c->xAxis()->addMark(m_dataSeriesAMinTime,0x8000FF00,"Min","arialbd.ttf",7);
		Mark *yMarkMax = c->yAxis()->addMark(m_dataSeriesAMaxVal,0x800000FF,"Max","arialbd.ttf",7);
		Mark *yMarkMin = c->yAxis()->addMark(m_dataSeriesAMinVal,0x8000FF00,"Min","arialbd.ttf",7);
		xMarkMax->setAlignment(Chart::Left);
		xMarkMin->setAlignment(Chart::Right);
		yMarkMax->setAlignment(Chart::BottomCenter);
		yMarkMin->setAlignment(Chart::TopCenter);
		xMarkMax->setDrawOnTop(false);
		xMarkMin->setDrawOnTop(false);
		yMarkMax->setDrawOnTop(false);
		yMarkMin->setDrawOnTop(false);
	}

	///////////////////////////////////////////////////////////////////////////////////////
	// Step 2 - Add data to chart
	///////////////////////////////////////////////////////////////////////////////////////

	// 
	// In this example, we represent the data by lines. You may modify the code below if 
	// you want to use other representations (areas, scatter plot, etc).
	//

	// Add a line layer for the lines, using a line width of 2 pixels
	Layer *layer = c->addLineLayer();
	layer->setLineWidth(1);

	// Now we add the 3 data series to a line layer, using the color red (ff0000), green
	// (00cc00) and blue (0000ff)
	//layer->setXData(DoubleArray(viewPortTimeStamps, noOfPoints));
	//(layer->addDataSet(DoubleArray(viewPortDataSeriesA, noOfPoints), 0xff0000, m_dataTitleA))->setDataSymbol(Chart::DiamondShape,3,-1,-1,1);
	//layer->addDataSet(DoubleArray(viewPortDataSeriesB, noOfPoints), 0x00cc00, "AC");
	//layer->addDataSet(DoubleArray(viewPortDataSeriesC, noOfPoints), 0x0000ff, "Temperature");


    // Add the first data series
		if (m_timeStampsA.len)
		{
			LineLayer *layer0 = c->addLineLayer();
			(layer0->addDataSet(DoubleArray(viewPortDataSeriesA, noOfPointsA), 0xff0000, m_dataTitleA))->setDataSymbol(Chart::DiamondShape, 3,-1,-1,1);
			layer0->setXData(DoubleArray(viewPortTimeStampsA, noOfPointsA));
			layer0->setLineWidth(1);
			layer0->setFastLineMode(true);
		}
		if (m_multiline)
		{
			if (m_timeStampsB.len)
			{
				// Add the second data series
				LineLayer *layer1 = c->addLineLayer();
				(layer1->addDataSet(DoubleArray(viewPortDataSeriesB, noOfPointsB), 0x00ff00, m_dataTitleB))->setDataSymbol(Chart::TriangleShape, 3,-1,-1,1);
				layer1->setXData(DoubleArray(viewPortTimeStampsB, noOfPointsB));
				layer1->setLineWidth(1);
				layer1->setFastLineMode(true);
			}

			if (m_timeStampsC.len)
			{
				// Add the third data series
				LineLayer *layer2 = c->addLineLayer();
				(layer2->addDataSet(DoubleArray(viewPortDataSeriesC, noOfPointsC), 0x0000ff, m_dataTitleC))->setDataSymbol(Chart::CircleShape, 3,-1,-1,1);
				layer2->setXData(DoubleArray(viewPortTimeStampsC, noOfPointsC));
				layer2->setLineWidth(1);
				layer2->setFastLineMode(true);
			}
		}



	///////////////////////////////////////////////////////////////////////////////////////
	// Step 3 - Set up x-axis scale
	///////////////////////////////////////////////////////////////////////////////////////

	// Set x-axis date scale to the view port date range. 
	c->xAxis()->setDateScale(viewPortStartDate, viewPortEndDate);

	//
	// In the current demo, the x-axis range can be from a few years to a few days. We can 
	// let ChartDirector auto-determine the date/time format. However, for more beautiful 
	// formatting, we set up several label formats to be applied at different conditions. 
	//

	// If all ticks are yearly aligned, then we use "yyyy" as the label format.
	c->xAxis()->setFormatCondition("align", 360 * 86400);
	c->xAxis()->setLabelFormat("{value|yyyy}");

	// If all ticks are monthly aligned, then we use "mmm yyyy" in bold font as the first 
	// label of a year, and "mmm" for other labels.
	c->xAxis()->setFormatCondition("align", 30 * 86400);
	c->xAxis()->setMultiFormat(Chart::StartOfYearFilter(), "<*font=bold*>{value|mmm yyyy}", 
		Chart::AllPassFilter(), "{value|mmm}");

	// If all ticks are daily algined, then we use "mmm dd<*br*>yyyy" in bold font as the 
	// first label of a year, and "mmm dd" in bold font as the first label of a month, and
	// "dd" for other labels.
	c->xAxis()->setFormatCondition("align", 86400);
	c->xAxis()->setMultiFormat(Chart::StartOfYearFilter(), 
		"<*block,halign=left*><*font=bold*>{value|mmm dd<*br*>yyyy}", 
		Chart::StartOfMonthFilter(), "<*font=bold*>{value|mmm dd}");
	c->xAxis()->setMultiFormat(Chart::AllPassFilter(), "{value|dd}");

	// For all other cases (sub-daily ticks), use "hh:nn<*br*>mmm dd" for the first label of
	// a day, and "hh:nn" for other labels.
	c->xAxis()->setFormatCondition("else");
	c->xAxis()->setMultiFormat(Chart::StartOfDayFilter(), 
		"<*font=bold*>{value|hh:nn:ss<*br*>mmm dd}", Chart::AllPassFilter(), "{value|hh:nn:ss}");

	///////////////////////////////////////////////////////////////////////////////////////
	// Step 4 - Set up y-axis scale
	///////////////////////////////////////////////////////////////////////////////////////

	if ((viewer->getZoomDirection() == Chart::DirectionHorizontal) || 
		((m_minValue == 0) && (m_maxValue == 0)))
	{

		if((m_ChartViewer.getViewPortTop()==0)&&
			(m_ChartViewer.getViewPortHeight()==1)&&
			(m_ChartViewer.getViewPortLeft()==0)&&
			(m_ChartViewer.getViewPortWidth()==1)&&m_showMinMax)
		{ //At complete zoom out, show min and max lines
			c->yAxis()->setLinearScale(m_dataSeriesAMinVal-(m_dataSeriesAMaxVal-m_dataSeriesAMinVal)*0.05,m_dataSeriesAMaxVal+(m_dataSeriesAMaxVal-m_dataSeriesAMinVal)*0.05);
			c->yAxis()->setRounding(false, false);
		}
		else
		{
			// y-axis is auto-scaled - save the chosen y-axis scaled to support xy-zoom mode
			c->layout();
			m_minValue = c->yAxis()->getMinValue();
			m_maxValue = c->yAxis()->getMaxValue();
		}
	}
	else
	{
		// xy-zoom mode - compute the actual axis scale in the view port 
		double axisLowerLimit =  m_maxValue - (m_maxValue - m_minValue) * 
			(viewer->getViewPortTop() + viewer->getViewPortHeight());
		double axisUpperLimit =  m_maxValue - (m_maxValue - m_minValue) * 
			viewer->getViewPortTop();
		// *** use the following formula if you are using a log scale axis ***
		// double axisLowerLimit = m_maxValue * pow(m_minValue / m_maxValue, 
		//  viewer->getViewPortTop() + viewer->getViewPortHeight());
		// double axisUpperLimit = m_maxValue * pow(m_minValue / m_maxValue, 
		//  viewer->getViewPortTop());

		// use the zoomed-in scale
		c->yAxis()->setLinearScale(axisLowerLimit, axisUpperLimit);
		c->yAxis()->setRounding(false, false);
	}

	///////////////////////////////////////////////////////////////////////////////////////
	// Step 5 - Display the chart
	///////////////////////////////////////////////////////////////////////////////////////

	// Set the chart image to the WinChartViewer
	delete m_ChartViewer.getChart();
	m_ChartViewer.setChart(c);

		 // Output the chart as BMP
  m_bmp = c->makeChart(Chart::BMP);

	// Free resources
	delete[] viewPortTimeStampsA;
	delete[] viewPortTimeStampsB;
	delete[] viewPortTimeStampsC;
	delete[] viewPortDataSeriesA;
	delete[] viewPortDataSeriesB;
	delete[] viewPortDataSeriesC;
}

//
// Update the image map
//
void CZoomscrolldemoDlg::updateImageMap(CChartViewer *viewer)
{
	if (0 == viewer->getImageMapHandler())
	{
		// no existing image map - creates a new one
		viewer->setImageMap(viewer->getChart()->getHTMLImageMap("clickable", "",
			"title='[{dataSetName}] {x|mmm dd, yyyy hh:nn:ss}: {value|6}'"));
	}
}

/////////////////////////////////////////////////////////////////////////////
// General utilities

//
// Get the default background color
//
int CZoomscrolldemoDlg::getDefaultBgColor()
{
	LOGBRUSH LogBrush; 
	HBRUSH hBrush = (HBRUSH)SendMessage(WM_CTLCOLORDLG, (WPARAM)CClientDC(this).m_hDC, 
		(LPARAM)m_hWnd); 
	::GetObject(hBrush, sizeof(LOGBRUSH), &LogBrush); 
	int ret = LogBrush.lbColor;
	return ((ret & 0xff) << 16) | (ret & 0xff00) | ((ret & 0xff0000) >> 16);
}

//
// Load an icon resource into a button
//
void CZoomscrolldemoDlg::loadButtonIcon(int buttonId, int iconId, int width, int height)
{
	GetDlgItem(buttonId)->SendMessage(BM_SETIMAGE, IMAGE_ICON, (LPARAM)::LoadImage(
		AfxGetResourceHandle(), MAKEINTRESOURCE(iconId), IMAGE_ICON, width, height, 
		LR_DEFAULTCOLOR));  
}

void CZoomscrolldemoDlg::OnBnClickedButtonPrint()
{
	char filename[MAX_PATH]="";

	if (!m_printDlgPtr) return;

	//CPrintDialog printDlg(FALSE);
	if (m_printDlgPtr->DoModal() == IDCANCEL) return;

	CDC dc;
	if (!dc.Attach(m_printDlgPtr->GetPrinterDC())) 
	{
		AfxMessageBox(_T("No printer found!")); return;
	} 

	dc.m_bPrinting = TRUE; 
	DOCINFO di;    
	// Initialise print document details
	::ZeroMemory (&di, sizeof (DOCINFO));
	di.cbSize = sizeof (DOCINFO);
	di.lpszDocName = filename; 
	BOOL bPrintingOK = dc.StartDoc(&di); // Begin a new print job 
	// Get the printing extents
	// and store in the m_rectDraw field of a 
	// CPrintInfo object
	CPrintInfo Info;
	Info.SetMaxPage(1); // just one page 
	int maxw = dc.GetDeviceCaps(HORZRES);
	int maxh = dc.GetDeviceCaps(VERTRES); 
	Info.m_rectDraw.SetRect(0, 0, maxw, maxh); 
	for (UINT page = Info.GetMinPage(); page <=Info.GetMaxPage() && bPrintingOK; page++) 
	{
		dc.StartPage();    // begin new page
		Info.m_nCurPage = page;

    // The BITMAPINFOHEADER is 14 bytes offset from the beginning
    LPBITMAPINFO header = (LPBITMAPINFO)(m_bmp.data + 14);

    // The bitmap data
    LPBYTE bitData = (LPBYTE)(m_bmp.data) +
        ((LPBITMAPFILEHEADER)(m_bmp.data))->bfOffBits;

		// Output to device context
    StretchDIBits(dc.m_hDC, 
									0, 0, maxw, maxh,
                  0, 0, header->bmiHeader.biWidth, header->bmiHeader.biHeight,
                  bitData, header, DIB_RGB_COLORS, SRCCOPY);

		bPrintingOK = (dc.EndPage() > 0);   // end page
	} 

	if (bPrintingOK)
		dc.EndDoc(); // end a print job
	else 
		dc.AbortDoc();           // abort job.
}

void CZoomscrolldemoDlg::OnBnClickedButtonSavechart()
{
	CString fileNameDefault;
	//fileNameDefault=m_chartTitle+".jpg";
	fileNameDefault="chart.jpg";

	CFileDialog fileDialog(FALSE,".jpg",fileNameDefault,OFN_OVERWRITEPROMPT, "JPG|*.jpg|JPEG|*.jpeg|PNG|*.png|GIF|*.gif|WBMP|*.wbmp|BMP|*.bmp|SVG|*.svg|SVGZ|*.svgz||",NULL,0,TRUE);

	if( fileDialog.DoModal()==IDOK )
	{
		if (!(m_ChartViewer.getChart())->makeChart(fileDialog.GetPathName()))
			MessageBox("Error saving chart to file.","Error",MB_OK|MB_ICONERROR);
	}
}



void CZoomscrolldemoDlg::OnBnClickedButtonZoomall()
{
	// Viewport is always unzoomed as y-axis is auto-scaled
	m_ChartViewer.setViewPortTop(0);
	m_ChartViewer.setViewPortHeight(1);
	m_ChartViewer.setViewPortLeft(0);
	m_ChartViewer.setViewPortWidth(1);

	// Update chart to auto-scale axis
	m_ChartViewer.updateViewPort(true, true);
}


void CZoomscrolldemoDlg::OnBnClickedButtonPrevwave()
{
	if (m_waveSegmentCurrent) m_waveSegmentCurrent--;
	UpdateWaveSegment();
}


void CZoomscrolldemoDlg::OnBnClickedButtonNextwave()
{
	if (m_waveSegmentCurrent<(m_waveSegmentsCount-1)) m_waveSegmentCurrent++;
	UpdateWaveSegment();
}


void CZoomscrolldemoDlg::OnBnClickedButtonFirstwave()
{
	m_waveSegmentCurrent=0;
	UpdateWaveSegment();
}


void CZoomscrolldemoDlg::OnBnClickedButtonLastwave()
{
	m_waveSegmentCurrent=m_waveSegmentsCount-1;
	UpdateWaveSegment();
}


void CZoomscrolldemoDlg::UpdateWaveSegment()
{
	UINT32 i;
	((CWnd*)GetDlgItem(IDC_BUTTON_PREVWAVE))->EnableWindow(m_waveSegmentCurrent!=0?TRUE:FALSE);
	((CWnd*)GetDlgItem(IDC_BUTTON_NEXTWAVE))->EnableWindow(m_waveSegmentCurrent!=(m_waveSegmentsCount-1)?TRUE:FALSE);
	((CWnd*)GetDlgItem(IDC_BUTTON_FIRSTWAVE))->EnableWindow(m_waveSegmentCurrent!=0?TRUE:FALSE);
	((CWnd*)GetDlgItem(IDC_BUTTON_LASTWAVE))->EnableWindow(m_waveSegmentCurrent!=(m_waveSegmentsCount-1)?TRUE:FALSE);

	m_minValue = m_maxValue = 0;            // y axes ranges

	m_timeStampsA=DoubleArray(m_timeStampsB.data+m_waveSegments[m_waveSegmentCurrent].startIndex,m_waveSegments[m_waveSegmentCurrent].endIndex-m_waveSegments[m_waveSegmentCurrent].startIndex);
	m_dataSeriesA=DoubleArray(m_dataSeriesB.data+m_waveSegments[m_waveSegmentCurrent].startIndex,m_waveSegments[m_waveSegmentCurrent].endIndex-m_waveSegments[m_waveSegmentCurrent].startIndex);

	//Compute min/max
	m_dataSeriesAMinTime=m_timeStampsA[0];
	m_dataSeriesAMinVal=m_dataSeriesA[0];
	m_dataSeriesAMaxTime=m_timeStampsA[0];
	m_dataSeriesAMaxVal=m_dataSeriesA[0];
	for (i=0; i<m_dataSeriesA.len; i++)
	{
		if (m_dataSeriesA[i]<m_dataSeriesAMinVal) {m_dataSeriesAMinTime=m_timeStampsA[i];m_dataSeriesAMinVal=m_dataSeriesA[i];}
		if (m_dataSeriesA[i]>m_dataSeriesAMaxVal) {m_dataSeriesAMaxTime=m_timeStampsA[i];m_dataSeriesAMaxVal=m_dataSeriesA[i];}
	}

	// Earliest date is the first timestamp
	m_minDate = m_timeStampsA[0];
	m_maxDate = m_timeStampsA[m_timeStampsA.len - 1];
	// Duration is the seconds elapsed of the last timestamp from the earliest date
	m_dateRange = m_maxDate - m_minDate;

	m_currentDuration=m_dateRange;

	// Convert the start time (in chartTime format) as an MFC CTime value
	int startYMD = Chart::getChartYMD(m_minDate/*m_timeStampsA[0]*/);
	int startHMS = (int)fmod(m_minDate/*m_timeStampsA[0]*/, 86400);
	CTime startDate = CTime(startYMD / 10000, (startYMD % 10000) / 100, startYMD % 100,
		startHMS / 3600, (startHMS % 3600) / 60, startHMS % 60);

	// Convert the end time (in chartTime format) as an MFC CTime value
	int endYMD = Chart::getChartYMD(m_maxDate/*m_timeStampsA[m_timeStampsA.len - 1]*/);
	int endHMS = (int)fmod(m_maxDate/*m_timeStampsA[m_timeStampsA.len - 1]*/, 86400);
	CTime endDate = CTime(endYMD / 10000, (endYMD % 10000) / 100, endYMD % 100,
		endHMS / 3600, (endHMS % 3600) / 60, endHMS % 60);

	// Set the startDate and endDate to the CDateTimeCtrl control 
	m_StartDate.SetRange(&startDate, &endDate);

	// In this demo, the maximum zoom-in is set to 10 days (1 day = 86400 seconds)
	m_minDuration = 2; //1 * 86400;

	// Set up the ChartViewer to reflect the visible and minimum duration
	m_ChartViewer.setZoomInWidthLimit(m_minDuration / m_dateRange);
	m_ChartViewer.setViewPortWidth(m_currentDuration / m_dateRange);
	m_ChartViewer.setViewPortLeft(1 - m_ChartViewer.getViewPortWidth());

	// Can update chart now
	m_ChartViewer.updateViewPort(true, true);
}

void CZoomscrolldemoDlg::OnBnClickedCheckShowminmax()
{
	if (UpdateData(TRUE))
	{
		// Update chart
		m_ChartViewer.updateViewPort(true, true);
	}
}


void CZoomscrolldemoDlg::OnBnClickedCheckNodecimation()
{
	if (UpdateData(TRUE))
	{
		// Update chart
		m_ChartViewer.updateViewPort(true, true);
	}
}
